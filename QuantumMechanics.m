(* ::Package:: *)

BeginPackage["QuantumMechanics`"];
IdM::usage="Identity matrix of size N; alias for built-in IdentityMatrix.\nInput: N (positive integer)";
Dagger::usage="Alias for ConjugateTranspose";
TProduct::usage="Returns ArrayFlatten[TensorProduct[A,B]].";
eList::usage="List of (orthonormal) basis vectors of size Nquanta. The definition is based on that of Id.\nInput: Nquana (positive integer)";
eVector::usage="A basis vector of size Nquanta, with ith nonzero element. Returns a zero vector of size Nquanta for i > Nquanta.\nInput: Nquanta (positive integer); i (positive integer)";
RaiseM::usage="Bosonic raising operator, acting on states of size Nquanta, in matrix form.\nInput: Nquanta (positive integer)";
LowerM::usage="Bosonic lowering operator, acting on states of size Nquanta, in matrix form.\nInput: Nquanta (positive integer)";
QRaiseM::usage="Same as RaiseM";
QLowerM::usage="Same as LowerM";
FRaiseM::usage="Fermionic raising operator constructed with the Jordan-Wigner mapping. Acts on states with Nquanta (2\[Times]Nsites) by creating a spin-sigma particle (sigma in 1/2,-1/2) on mode i (positive integer). 1\[LessEqual]i\[LessEqual]Nsite. Thus isigma + 2\[Times]i specifies the slot in the tensor productin which to insert cDaggerM.";
FLowerM::usage="Fermionic lowering operator constructed with the Jordan-Wigner mapping. Acts on states with Nquanta (2\[Times]Nsites) by annihilating a spin-sigma particle (sigma in 1/2,-1/2) on mode i (positive integer). 1\[LessEqual]i\[LessEqual]Nsite. Thus isigma + 2\[Times]i specifies the slot in the tensor productin which to insert cM.";
BLowerM::usage="Qubit (bosonic) lowering operator constructed with spin matrices. Acts on states with Nquanta (2^{number of particles}) by annihilating a spin-sigma particle (sigma in 1/2,-1/2) on mode i (positive integer).";
BRaiseM::usage="Qubit (bosonic) raising operator constructed with spin matrices. Acts on states with Nquanta (2^{number of particles}) by creating a spin-sigma particle (sigma in 1/2,-1/2) on mode i (positive integer).";
KetBraM::usage="The matrix |i><j|, which couples the ket i and bra j, which are basis vectors of size Nquanta. Returns a zero matrix for i or j > Nquanta.\nInput: Nquanta; i; j";
NumberM::usage="Number operator Sum_m m |m><m| for number states m=0,1,...,Nquanta in matrix form. \nInput: Nquanta";
QubitStateList::usage="Returns a list of 1-qubit states for a list of indices.";
QubitStateVector::usage="Returns a vector representation of a basis vector labeled by 1-qubit indices (indexing starts from 1) indexList";
FindQubitStateIndices::usage="Returns a list of 1-qubit indices (indexing starts from 1) that correspond to a basis vector (in the chosen representation).";
FindVectorIndex::usage="";
FindQuantumNumbers::usage="";
MapBasisElement::usage="Re-represent as basis vector with permuted indices.";
MapMatrix::usage="Re-represent a matrix in a basis with permuted indices.";
DisplaceM::usage="Displacement operator (matrix repre) for Nquanta and parameter alpha.";
CoherentState::usage="";
Wigner::usage="Wigner pseudo-probability distribution.";
RM::usage="Rotation matrix generated by Pauli matrices.";
RX::usage="Rotation matrix generated by Pauli matrix sigmaX.";
RY::usage="Rotation matrix generated by Pauli matrix sigmaY.";
RZ::usage="Rotation matrix generated by Pauli matrix sigmaZ.";
CNOTM::usage="CNOT matrix between the control qubit icontrol and target qubit itarget, for a state with Nqubit qubits.";
Begin["Private`"];
IdM[N_]:=IdentityMatrix[N];
Dagger[M_List]:=ConjugateTranspose[M];
TProduct[A_List,B_List]:=ArrayFlatten[TensorProduct[A,B]];
eList[Nquanta_]:=IdM[Nquanta];
eVector[Nquanta_,i_]:=Module[{},
	If[i>Nquanta||i<1,
	Print["Invalid index for e.\n"];
	Table[0,{i,1,Nquanta}],
	eList[Nquanta][[i]]
	]
];
RaiseM[Nquanta_]:=Table[If[i==(j+1),Sqrt[j],0],{i,1,Nquanta},{j,1,Nquanta}];
LowerM[Nquanta_]:=Table[If[j==(i+1),Sqrt[i],0],{i,1,Nquanta},{j,1,Nquanta}];
QRaiseM[Nquanta_]:=RaiseM[Nquanta];
QLowerM[Nquanta_]:=LowerM[Nquanta];
FLowerM[Nquanta_,i_,sigma_]:=Module[{cM,Z,isigma,quantaIndex,cMatrix},
  If[i>Nquanta,
    Print["Invalid index for a lowering operator of Nquanta ",Nquanta,"."];
    ConstantArray[0,{Nquanta,Nquanta}],
    cM={{0,1},{0,0}};
    Z=PauliMatrix[3];
    isigma=sigma+1/2;(*convert +-1/2 to -1 or 0*)
    quantaIndex=2*i+isigma;
    cMatrix=1;
    Do[
      Do[
        (*2\[Times]k+sigma runs from 1 to *)
        If[2*k+s<quantaIndex,
          cMatrix=ArrayFlatten[TensorProduct[cMatrix,Z]],
          If[2*k+s==quantaIndex,
            cMatrix=ArrayFlatten[TensorProduct[cMatrix,cM]],
            cMatrix=ArrayFlatten[TensorProduct[cMatrix,IdM[2]]]
          ]
        ];
      (*Print[cMatrix]*)
      ,{s,0,1}];
    ,{k,1,Nquanta/2}];
  ];
  cMatrix
];
FRaiseM[Nquanta_,i_,sigma_]:=Module[{cDaggerM,Z,isigma,quantaIndex,cMatrix},
  (*Nquanta is equal to Nsites\[Times]2 for spin-1/2 fermions,
    and 1\[LessEqual]i\[LessEqual]Nsite. Thus isigma + 2\[Times]i specifies the slot in the tensor product
    in which to insert cDaggerM*)
  If[i>Nquanta,
    Print["Invalid index for a lowering operator of Nquanta ",Nquanta,"."];
    ConstantArray[0,{Nquanta,Nquanta}],
    cDaggerM={{0,0},{1,0}};
    Z=PauliMatrix[3];
    isigma=sigma+1/2;(*convert +-1/2 to 0 or 1*)
    quantaIndex=2*i+isigma;
    cMatrix=1;
    Do[
      Do[
        (*2\[Times]k+sigma runs from 1 to *)
        If[2*k+s<quantaIndex,
          cMatrix=ArrayFlatten[TensorProduct[cMatrix,Z]],
          If[2*k+s==quantaIndex,
            cMatrix=ArrayFlatten[TensorProduct[cMatrix,cDaggerM]],
            cMatrix=ArrayFlatten[TensorProduct[cMatrix,IdM[2]]]
          ]
        ];
      (*Print[cMatrix]*)
      ,{s,0,1}];
    ,{k,1,Nquanta/2}];
  ];
  cMatrix
];
BLowerM[Nquanta_,i_,sigma_]:=Module[{cM,isigma,quantaIndex,cMatrix},
  If[i>Nquanta,
    Print["Invalid index for a lowering operator of Nquanta ",Nquanta,"."];
    ConstantArray[0,{Nquanta,Nquanta}],
    cM={{0,1},{0,0}};
    isigma=sigma+1/2;(*convert +-1/2 to 0 or 1*)
    quantaIndex=2*i+isigma;
    cMatrix=1;
    Do[
      Do[
        (*2\[Times]k+sigma runs from 1 to *)
        If[2*k+s<quantaIndex,
          cMatrix=ArrayFlatten[TensorProduct[cMatrix,IdM[2]]],
          If[2*k+s==quantaIndex,
            cMatrix=ArrayFlatten[TensorProduct[cMatrix,cM]],
            cMatrix=ArrayFlatten[TensorProduct[cMatrix,IdM[2]]]
          ]
        ];
      (*Print[cMatrix]*)
      ,{s,0,1}];
    ,{k,1,Nquanta/2}];
  ];
  cMatrix
];
BRaiseM[Nquanta_,i_,sigma_]:=Module[{cDaggerM,isigma,quantaIndex,cMatrix},
  If[i>Nquanta,
    Print["Invalid index for a lowering operator of Nquanta ",Nquanta,"."];
    ConstantArray[0,{Nquanta,Nquanta}],
    cDaggerM={{0,0},{1,0}};
    isigma=sigma+1/2;(*convert +-1/2 to 0 or 1*)
    quantaIndex=2*i+isigma;
    cMatrix=1;
    Do[
      Do[
        (*2\[Times]k+sigma runs from 1 to *)
        If[2*k+s<quantaIndex,
          cMatrix=ArrayFlatten[TensorProduct[cMatrix,IdM[2]]],
          If[2*k+s==quantaIndex,
            cMatrix=ArrayFlatten[TensorProduct[cMatrix,cDaggerM]],
            cMatrix=ArrayFlatten[TensorProduct[cMatrix,IdM[2]]]
          ]
        ];
      (*Print[cMatrix]*)
      ,{s,0,1}];
    ,{k,1,Nquanta/2}];
  ];
  cMatrix
];
KetBraM[Nquanta_,i_,j_]:=Module[{},
	If[i>Nquanta||j>Nquanta||i<1||j<1,
	  Print["Invalid index for KetBraM.\n"];
	  ConstantArray[0,{Nquanta,Nquanta}],
	  ArrayFlatten[TensorProduct[eVector[Nquanta,i],eVector[Nquanta,j]]]
	]
];
NumberM[Nquanta_]:=Sum[m*KetBraM[m,m],{m,1,Nquanta}];
QubitStateList[indexList_]:=Module[{eList,eVector},
  eList={};
  Do[
    If[(indexList[[k]]!=1)&&(indexList[[k]]!=2),
      Print["Warning: incorrect index in argument number ",k,"indexList[[k]]:",indexList[[k]]]
    ];
    eList=Append[eList,If[indexList[[k]]==1,{1,0},If[indexList[[k]]==2,{0,1},{0,0}]]];
  ,{k,1,Length[indexList]}];
  eList
];
QubitStateVector[indexList_]:=Module[{eList,eVector},
  eList=QubitStateList[indexList];
  eVector=1;
  Do[
    eVector=TensorProduct[eVector,eList[[k]]]
  ,{k,1,Length[indexList]}];
  Flatten[eVector]
];
FindQubitStateIndices[e_List]:=Module[{tuples,indexList},
  tuples=Tuples[{1,2},Log[2,Length[e]]];
  indexList={};
  Do[
	If[e==QubitStateVector[tuples[[i]]],
      indexList=tuples[[i]];
      Break[]
    ];
  ,{i,1,Length[tuples]}];
  indexList
];
FindVectorIndex[indexList_]:=Module[{index,vector},
  index=0;
  vector=QubitStateVector[indexList];
  Do[
    If[vector[[k]]==1,
      index=k;
      Break[]
    ]
  ,{k,1,Length[vector]}];
  index
];
FindQuantumNumbers[stateVector_List]:=Module[
{len,Nquanta,Nsites,qNumbers,indices,vacuum,state,basisIndex,stateIndex},
  (*Input: basis vector*)
  len=Length[stateVector];
  Nquanta=IntegerPart[Log[2,len]];
  Nsites=Nquanta/2;
  If[Count[stateVector,x_ /;x!=0]!=1,
    Print["Error in FindQuantumNumber: Please use a basis vector as the input."];
    {},
    (*Else find quantum numbers*)
    basisIndex=SparseArray[stateVector]["NonzeroPositions"][[1]][[1]];
    qNumbers={};
    vacuum=Table[0,{i,1,len}];
    vacuum[[1]]=1;
    indices=Flatten[Table[{i,j},{i,1,Nsites},{j,{1/2,-1/2}}],1];
    Do[
      state=vacuum;
      Do[
        state=FRaiseM[Nquanta,indexPair[[1]],indexPair[[2]]].state;
      ,{indexPair,indexPairSet}];
     stateIndex=SparseArray[state]["NonzeroPositions"][[1]][[1]];
     If[basisIndex==stateIndex,
       qNumbers=indexPairSet;
       Return[qNumbers]
     ];
    ,{indexPairSet,Subsets[indices]}]; 
  ];
  qNumbers
];
MapBasisElement[e_List,perm_]:=Module[{indices,vector},
(*perms is the vector with the places of the new indices, i.e. a
  permutation of {1,2,...,Nqubits}*)
  indices=FindQubitStateIndices[e];
  On[Assert];
  Assert[Length[perm]==Length[indices]];
  Off[Assert];
  vector=QubitStateVector[Permute[indices,perm]];
  vector
];
MapMatrix[M_List,perm_]:=Module[{newM},
  newM=Table[0,{i,1,Dimensions[M][[1]]},{j,1,Dimensions[M][[2]]}];
  On[Assert];
  Assert[Dimensions[M][[1]]==Dimensions[M][[2]]];
  Off[Assert];
  Do[
    Do[
      newM=newM+M[[i,j]]*ArrayFlatten[TensorProduct[MapBasisElement[e[Dimensions[M][[1]],i],perm],MapBasisElement[e[Dimensions[M][[1]],j],perm]]];
    ,{i,1,Dimensions[M][[1]]}];
  ,{j,1,Dimensions[M][[2]]}];
  newM
];
DisplaceM[Nquanta_,\[Alpha]_]:=N[MatrixExp[N[(Re[\[Alpha]]+I*Im[\[Alpha]])*RaiseM[Nquanta]-(Re[\[Alpha]]-I*Im[\[Alpha]])*LowerM[Nquanta]]]];
CoherentState[Nquanta_,\[Alpha]_]:=Exp[-(Re[\[Alpha]]+Im[\[Alpha]])^2/2]*Sum[\[Alpha]^n/Sqrt[n!]*If[n>0,MatrixPower[RaiseM[Nquanta],n],IdM[Nquanta]].e[Nquanta,1],{n,0,Nquanta}];
Wigner[Nquanta_,z_,rho_List]:=N[(2/\[Pi])]*Tr[DisplaceM[Nquanta,-z].rho.DisplaceM[Nquanta,z].MatrixExp[N[I*\[Pi]*RaiseM[Nquanta].LowerM[Nquanta]]]];
End[];
RM[\[Alpha]_List,Pauli_List]:=MatrixExp[I*Sum[\[Alpha][[k]]*Pauli[[k]],{k,1,Min[Length[Pauli],Length[\[Alpha]]]}]];
RX[\[Alpha]_]:=MatrixExp[I*\[Alpha]*PauliMatrix[1]];
RY[\[Alpha]_]:=MatrixExp[I*\[Alpha]*PauliMatrix[2]];
RZ[\[Alpha]_]:=MatrixExp[I*\[Alpha]*PauliMatrix[3]];
CNOTM[icontrol_,itarget_,Nqubits_]:=Module[{cnot},
    (*construct the basis states for qi and qj*)
    cnot=Table[0,{i,1,2^Nqubits},{j,1,2^Nqubits}];
    cnot
];
EndPackage[];
